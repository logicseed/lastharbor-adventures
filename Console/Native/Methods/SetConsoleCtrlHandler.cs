// Copyright © 2018 Marc King <marc@marc.software> - All Rights Reserved
//
// SPDX-License-Identifier: MIT
//
// This work is licensed under the terms of the MIT license. See <LICENSE.md> for more information.

using System;
using System.Runtime.InteropServices;

namespace LastHarbor.Console.Native
{
    /// <summary>
    /// Interop methods to access native console functions.
    /// </summary>
    internal static partial class NativeMethods
    {
        /// <summary>
        /// <para>
        /// Adds or removes an application-defined <see cref="HandlerRoutine"/> function from the
        /// list of handler functions for the calling process.
        /// </para>
        /// <para>
        /// If no handler function is specified, the function sets an inheritable attribute that
        /// determines whether the calling process ignores CTRL+C signals.
        /// </para>
        /// </summary>
        /// <param name="HandlerRoutine">
        /// A pointer to the application-defined <see cref="HandlerRoutine"/> function to be added or
        /// removed. This parameter can be <c>NULL</c>.
        /// </param>
        /// <param name="Add">
        /// <para>
        /// If this parameter is <c>TRUE</c>, the handler is added; if it is <c>FALSE</c>, the
        /// handler is removed.
        /// </para>
        /// <para>
        /// If the <paramref name="HandlerRoutine"/> parameter is <c>NULL</c>, a <c>TRUE</c> value
        /// causes the calling process to ignore CTRL+C input, and a <c>FALSE</c> value restores
        /// normal processing of CTRL+C input. This attribute of ignoring or processing CTRL+C is
        /// inherited by child processes.
        /// </para>
        /// </param>
        /// <returns>
        /// <para>
        /// If the function succeeds, the return value is <c>TRUE</c>.
        /// </para>
        /// <para>
        /// If the function fails, the return value is <c>FALSE</c>. To get extended error
        /// information, call <see cref="Marshal.GetLastWin32Error"/>.
        /// </para>
        /// </returns>
        /// <remarks>
        /// <para>
        /// This function provides a similar notification for console application and services that
        /// <c>WM_QUERYENDSESSION</c> provides for graphical applications with a message pump. You
        /// could also use this function from a graphical application, but there is no guarantee it
        /// would arrive before the notification from <c>WM_QUERYENDSESSION</c>.
        /// </para>
        /// <para>
        /// Each console process has its own list of application-defined <see cref="HandlerRoutine"/>
        /// functions that handle CTRL+C and CTRL+BREAK signals. The handler functions also handle
        /// signals generated by the system when the user closes the console, logs off, or shuts down
        /// the system. Initially, the handler list for each process contains only a default handler
        /// function that calls the <see cref="ExitProcess"/> function. A console process adds or
        /// removes additional handler functions by calling the <c>SetConsoleCtrlHandler</c>
        /// function, which does not affect the list of handler functions for other processes. When a
        /// console process receives any of the control signals, its handler functions are called on
        /// a last-registered, first-called basis until one of the handlers returns <c>TRUE</c>. If
        /// none of the handlers returns <c>TRUE</c>, the default handler is called.
        /// </para>
        /// <para>
        /// For console processes, the CTRL+C and CTRL+BREAK key combinations are typically treated
        /// as signals ( <c>CTRL_C_EVENT</c> and <c>CTRL_BREAK_EVENT</c>). When a console window with
        /// the keyboard focus receives CTRL+C or CTRL+BREAK, the signal is typically passed to all
        /// processes sharing that console.
        /// </para>
        /// <para>
        /// CTRL+BREAK is always treated as a signal, but typical CTRL+C behavior can be changed in
        /// three ways that prevent the handler functions from being called:
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// The <see cref="SetConsoleMode"/> function can disable the <c>ENABLE_PROCESSED_INPUT</c>
        /// mode for a console's input buffer, so CTRL+C is reported as keyboard input rather than as
        /// a signal.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Calling <c>SetConsoleCtrlHandler</c> with the <c>NULL</c> and <c>TRUE</c> arguments
        /// causes the calling process to ignore CTRL+C signals. This attribute is inherited by child
        /// processes, but it can be enabled or disabled by any process without affecting existing
        /// processes.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// If a console process is being debugged and CTRL+C signals have not been disabled, the
        /// system generates a <c>DBG_CONTROL_C</c> exception. This exception is raised only for the
        /// benefit of the debugger, and an application should never use an exception handler to deal
        /// with it. If the debugger handles the exception, an application will not notice the
        /// CTRL+C, with one exception: alertable waits will terminate. If the debugger passes the
        /// exception on unhandled, CTRL+C is passed to the console process and treated as a signal,
        /// as previously discussed.
        /// </description>
        /// </item>
        /// </list>
        /// </para>
        /// <para>
        /// A console process can use the <see cref="GenerateConsoleCtrlEvent"/> function to send a
        /// CTRL+C or CTRL+BREAK signal to a console process group.
        /// </para>
        /// <para>
        /// The system generates <c>CTRL_CLOSE_EVENT</c>, <c>CTRL_LOGOFF_EVENT</c>, and
        /// <c>CTRL_SHUTDOWN_EVENT</c> signals when the user closes the console, logs off, or shuts
        /// down the system so that the process has an opportunity to clean up before termination.
        /// Console functions, or any C run-time functions that call console functions, may not work
        /// reliably during processing of any of the three signals mentioned previously. The reason
        /// is that some or all of the internal console cleanup routines may have been called before
        /// executing the process signal handler.
        /// </para>
        /// <para>
        /// If a console application loads the gdi32.dll or user32.dll library, the
        /// <c>HandlerRoutine</c> function that you specify when you call
        /// <c>SetConsoleCtrlHandler</c> does not get called for the <c>CTRL_LOGOFF_EVENT</c> and
        /// <c>CTRL_SHUTDOWN_EVENT</c> events. The operating system recognizes processes that load
        /// gdi32.dll or user32.dll as Windows applications rather than console applications. This
        /// behavior also occurs for console applications that do not call functions in gdi32.dll or
        /// user32.dll directly, but do call functions such as Shell functions that do in turn call
        /// functions in gdi32.dll or user32.dll.
        /// </para>
        /// <para>
        /// To receive events when a user signs out or the device shuts down in these circumstances,
        /// create a hidden window in your console application, and then handle the
        /// <c>WM_QUERYENDSESSION</c> and <c>WM_ENDSESSION</c> window messages that the hidden window
        /// receives. You can create a hidden window by calling the <see cref="CreateWindowEx"/>
        /// method with the <c>dwExStyle</c> parameter set to 0.
        /// </para>
        /// </remarks>
        /// <seealso href="https://docs.microsoft.com/en-us/windows/console/setconsolectrlhandler"/>
        ///
        [DllImport("kernel32.dll",
                   EntryPoint = "SetConsoleCtrlHandler",
                   SetLastError = true,
                   CharSet = CharSet.Unicode)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern Boolean SetConsoleCtrlHandler(
            [param: In, Optional]
            HandlerRoutine HandlerRoutine,

            [param: In, MarshalAs(UnmanagedType.Bool)]
            Boolean Add
        );
    }
}
